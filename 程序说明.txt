按功能来讲解该程序设计

1 -- 打印地图/菜单
{
调用了PrintMap()函数,该函数是通过txt文件输入到终端；
具体实现：
            使用getline函数将每一行数据给到str，输出str。getline函数遇到文件尾就结束；
另外设计的时候想让它这样输出
↓
刚开始启动程序时：
=========
菜单
>>(这个是输入选项)
=========

打开地图后：
=========
菜单
地图
>>
=========
实现这个功能的函数在PrintMenu()里；
具体实现：
              用Bool类型变量MapPrintOk判断地图是否打印，也就是判断用户是否按了1选项。根据MapPrintOk来决定打印完菜单后
的下一步是否打印地图。其中菜单中的5--管理员选项也是类似，根据你是不是管理员来打印不同的内容，例如是就打印A，
不是就打印B

}

2 -- 地图数据加载
{
地图的结点数据加载是通过类 MGraph来实现，具体实现在构造函数MGraph()里 --> for(int i=0;!ifile.eof()&&i<50;i++)
这个就是通过Node.txt文件加载在已经提前声明的私有成员 vertex 里。具体数据位地图的编号，名字，介绍。
//特别说明一下，vertex的数量已经提前规定好是50个。

其次就是加载地图结点之间的距离数据，这个数据在distance.txt文件保存。

如果你想表示从1到13的距离位120，那么输入格式位:  1>13>120
                                                           即: 出发点 > 目的地 > 距离
将这种格式的数据通过函数void inputString(char *filename,string str[])实现，它将文件的每一行数据都输入到string数组里
例如 第一行数据在 str[0]，第二行数据在 str[1]里，以此类推。
具体实现：
              通过while(!infile.eof())建立一个循环，如果读到文件结尾就结束循环，
循环中：{getline(infile,str[i]);  i++;}这里是将读到的一行数据写进数组str[i]中，然后i自增1，直到循环结束。


这些原始数据加载到 fileString[50]数组中。因为是string类型不是int类型，而且有>符号，所以需要分隔字符串
分割字符串的工作由 void return_data1(string str, string &str1, string &str2, string &str3)完成
其中str是A>B>C,.str1 str2 str3分别对于A B C。
具体实现：
             用了str.find()函数来找这个 > 字符，然后将ABC分别输入到str1，str2，str3中。

将string字符加载完毕后需要将string转换为int类型，这个工作由 int return_Number(string str) 函数完成
具体实现就是根据ASCII码做一些转换，这个函数不是我写的，它只支持两位数的转换，有点小拉，如果是百位数的话我估计它会出BUG。
}

3 -- 加载完后的事情是“地图功能实现”了
{
最短路径算法由MGraph类里面的void Dijkstra(int v,int a,int t)实现，由v出发到a，t是判断输出的模式。
具体实现：
             基本跟书上的没什么区别，不过我加了点功能，那就是在算法运行前先进行判断两点有没有边，
也就是说先判断 两个点它们有没有路，要是没有的话那肯定就不能到达了，直接return，不需要进行求最短路径了。
顺带一提，因为最短路径代表了这条路的距离肯定是最短的，所以最短距离也在这个算法里面实现，用distance储存了v到所有顶点的最短距离。
这个最短路径的算法的结果就是用一个string数组储存v到所有顶点的路径(前提是他们能够到达) 所以很自然的也用同样的方式储存最短距离了.
}

4 -- 查看地图景点信息
{
通过输入地图编号，然后遍历找到vertex[x],然后输出它的名字与信息。 没啥好讲的 = =
}
 
5 -- 文件操作
{
管理员可以修改景点，删除边的数据，增加边，甚至删除整个景点。

这里想着简单，但实现起来不是那么回事。因为数据都保存在txt文件中
基本上有关修改数据的函数都需要文件操作。
修改景点就是修改它的名字和信息，编号不能改。
而打开文件通过需要指定模式，你是把文件全删除写数据还是在文件尾写新数据需要指定文件输入模式，具体为 ios::(模式)
如果是修改文件中的某一行数据，你需要找到数据的位置进行修改，但修改完后它之后的数据就不见了，所以需要一个中继文件tmp.txt来辅助操作。
具体实现：
             打开两个文件，一个是源文件A一个是中继文件B
通过循环将A的数据逐行输出到B中，直到是你需要修改的数据行就停止，然后修改，完了之后这个数据也跟着输入到B。
( 这其实就是不把原来的数据输入进去，那就相当于你删了这个数据，删除数据行也是一个道理。)
输入完后，继续循环输出直到遇到文件尾。
然后通过同样的操作将B输出到A，当然文件输入模式当然是清理A之后再输入。

这个修改操作在整个程序里是一样的。

删除边的数据就麻烦了点，但修改或者删除边跟上面是一样的，这里将怎么识别边
上面讲了边是 以 A>B>C 的形式保存
用户需要输入A>B找边，这个分割字符串由void return_data2(string str, string &str1, string &str2)完成，
具体实现和上面提到的大同小异，可以看代码的注释 ^ ^

删除景点的话就是需要用户输入地图编号x，然后进行删除操作，
首先是通过地图编号在Node.txt找到相应地图数据然后进行删除
其次边数据的处理，跟上面一样的处理方式，需要将这个点与其他景点的边都要删除
具体实现：
             通过循环检测A>B中A或B是不是等于编号x，如果等于，删除!
读到文件尾循环结束，然后程序重新加载数据
哎这里我可能有些没有办法，如果边太多可能效率很慢，但你必须要检查所有的边有没有与x关联，所以
我感觉没有什么优化空间。

}

6 -- 管理员账号
{
首先这个我设计的算是一个小型用户系统，但账号数据以txt文件的形式来保存，所以它们的登录注册注销保存账号所需要的文件操作跟上面一样。
唯独想说的是可能是一个没有必要提及的小功能，
就是用户的UID号，这相当于用户在程序中的身份证。
假设就只有3个账号，如果UID为3的账户注销后，下一个账号注册时UID应该是4，这意味这UID号码只能一直递增，它表示有多少个用户注册过账号，也可以说是注册次数
实现这个功能需要创建txt文件来保持UID的最大值，因为程序重启之后需要知道UID的最大值，不然没法递增。
特别的是，如果压根没有账号，那么会把UID最大值设置为0，注册时会改变UID最大值。
}


问题：在增加边的函数里我要求输入格式为A>B>C，但你如果输入A>B，数据会写入且无法删除，需要一个检测输入格式的函数
 ↑
这个问题已经解决了，具体是新弄了个void check_str(string str, string &A, string &B, string &C)函数来检测
